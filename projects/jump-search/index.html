<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jump Search</title>
    <link rel="stylesheet" href="./stylesheet/bootstrap.min.css"/>
    <link rel="stylesheet" href="./stylesheet/font-awesome/css/font-awesome.css"/>
</head>
<body>
    <div class="container">
        <div class="row">
            <div class="col-12">
                <h1 class="text-center">Jump Search Algorithm</h1>
            </div>
        </div>
        <div class="row">
            <table class="table table-bordered">
                <tr>
                    <th>TItle</th>
                    <th>Layout</th>
                    <th>Date</th>
                    <th>Last Modified</th>
                    <th>featured-image</th>
                    <th>Tags</th>
                    <th>Author/s</th>
                </tr>
                <tr>
                    <td>Jump Search in Python</td>
                    <td>Default</td>
                    <td>2020-10-02</td>
                    <td>2020-10-02</td>
                    <td>jump-search-python.jpg</td>
                    <td>jump-search</td>
                    <td><a href="https://github.com/soumalyatheking22012001" role="button" target="_blank" class="btn btn-dark"><span class="fa fa-github">&nbsp;/soumalyatheking22012001</a></td>
                </tr>
            </table>
        </div>
        <div class="row">
            <div  class="col-12">
                <h2>In this article we describe the working of Jump Search Algorithm</h2>
                <h3>Here the solution is implemented in Pyhton but it can be recreated in any language.</h3>
            </div>
        </div>
        <hr/>
        <div class="row">
            <div class="col-12">
                <h1>Requirments</h1>
            </div>
            <div class="col-12">
                <p class="text-info">No external libraries are required to run this program.You just only need python installed in your local machine. </p>
            </div>
        </div>
        <hr/>
        <div class="row">
            <div class="col-12">
                <h1>Description/Working</h1>
            </div>
            <div class="col-12">
                <p>Like Binary Search, Jump Search is a searching algorithm for sorted arrays. The basic idea is to check fewer elements (than linear search) by jumping ahead by fixed steps or skipping some elements in place of searching all elements.<br/>
                    For example, suppose we have an array arr[] of size n and block (to be jumped) size m. Then we search at the indexes arr[0], arr[m], arr[2m]…..arr[km] and so on. Once we find the interval (arr[km] < x < arr[(k+1)m]), we perform a linear search operation from the index km to find the element x.<br/>
                    Let’s consider the following array: (0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610). Length of the array is 16. Jump search will find the value of 55 with the following steps assuming that the block size to be jumped is 4.<br/>
                    <span class="text-info">STEP 1:</span> Jump from index 0 to index 4;<br/>
                    <span class="text-info">STEP 2:</span> Jump from index 4 to index 8;<br/>
                    <span class="text-info">STEP 3:</span> Jump from index 8 to index 12;<br/>
                    <span class="text-info">STEP 4:</span> Since the element at index 12 is greater than 55 we will jump back a step to come to index 8.<br/>
                    <span class="text-info">STEP 5:</span> Perform linear search from index 8 to get the element 55.
                </p>
            </div>
        </div>
        <hr/>
        <div class="row">
            <div class="col-12">
                <h1>What is the optimal block size to be skipped?</h1>
            </div>
            <div class="col-12">
                In the worst case, we have to do n/m jumps and if the last checked value is greater than the element to be searched for, we perform m-1 comparisons more for linear search. Therefore the total number of comparisons in the worst case will be ((n/m) + m-1). The value of the function ((n/m) + m-1) will be minimum when m = √n. Therefore, the best step size is <strong>m = √n.</strong>
            </div>
        </div>
        <hr/>
        <div class="row">
            <div class="col-12 col-sm-6">
                <h3>Time complexity: </h3>
                <h5>O(&#8730;n)</h5>
            </div>
            <div class="col-12 col-sm-6">
                <h3>Auxillary Space: </h3>
                <h5>O(1)</h5>
            </div>
        </div>
        <hr/>
        <div class="row">
            <div class="col-12">
                <h6 class="text-muted text-center">--END--</h6>
            </div>
        </div>
    </div>
</body>
</html>